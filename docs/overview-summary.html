<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Overview of ecapnp: the Cap'n Proto library for Erlang</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<h1>Overview of ecapnp: the Cap'n Proto library for Erlang</h1>
<p>Copyright © 2013, Andreas Stenius &lt;kaos@astekk.se&gt;</p>
<p><b>Version:</b> Oct 15 2013 14:21:02</p>
<p><b>Authors:</b> Andreas Stenius (<a href="mailto:kaos@astekk.se"><tt>kaos@astekk.se</tt></a>) [<em>web site:</em> <tt><a href="http://blog.astekk.se" target="_top">http://blog.astekk.se</a></tt>].</p>


<h3><a name="Description">Description</a></h3>

<p>The <code>ecapnp</code> library implements the a Cap'n Proto compiler plugin for
compiling schema files to Erlang header files.</p>

<p>The compiled schemas can then be included in any Erlang module to
process Cap'n Proto messages.</p>

To invoke the <a href="ecapnpc.html">Cap'n Proto Erlang compiler plugin</a>, it
is convenient to use the <code>capnpc-erl</code> script like this:
<pre>
  <code>capnpc -oerl my_schema.capnp</code>
</pre>

<p>This requires that <code>ecapnp/bin/ecapnpc-erl</code> is in your <code>$PATH</code>, and
that <code>ecapnp</code> is in your Erlang <a href="http://www.erlang.org/doc/man/code.html#id102620">libs path</a>
(hint: use the <code>ERL_LIBS</code> environment variable).</p>

<p>//TODO: See <a href="#Installation">Installation</a> for more details.</p>


<h3><a name="Schema">Schema</a></h3>

<p>The schema file, once compiled into an Erlang <code>.hrl</code>-file and included
in a module, exports a set of functions matching the name of the
schema for reading and writing Cap'n Proto messages.</p>

<p>Typically, this is <code>schema(root, ...)</code> for getting a <a href="http://kentonv.github.io/capnproto/encoding.html#messages">root
object</a>, <code>schema(get, Field, Object)</code> for reading and <code>schema(set,
Field, Value, Object)</code> for writing; where <code>schema</code> is the name of the
schema file.</p>

<p>There are also functions for type casting references to lists (or
text/data) or other structs (useful when reading fields of type
<code>object</code>).</p>

<p>See <a href="ecapnpc.html"><code>ecapnpc</code></a> for details on the compiled schema.</p>

<h4><a name="Example">Example</a></h4>

<p>A practical example is best to show what it looks like. </p>

<p>The <code>addressbook</code> example from Cap'n Proto has been ported and serves
as an example for ecapnp as well; and is included here as a reference
example.</p>

<h5><a name="Addressbook_schema">Addressbook schema</a></h5>

The <code>addressbook.capnp</code> schema is defined thus:
<pre><code>@0x9eb32e19f86ee174;

using Cxx = import "/capnp/c++.capnp";
$Cxx.namespace("addressbook");

struct Person {
  id @0 :UInt32;
  name @1 :Text;
  email @2 :Text;
  phones @3 :List(PhoneNumber);

  struct PhoneNumber {
    number @0 :Text;
    type @1 :Type;

    enum Type {
      mobile @0;
      home @1;
      work @2;
    }
  }

  employment :union {
    unemployed @4 :Void;
    employer @5 :Text;
    school @6 :Text;
    selfEmployed @7 :Void;
    # We assume that a person is only one of these.
  }
}

struct AddressBook {
  people @0 :List(Person);
}</code>
</pre>

And when compiled with <code>capnpc -oerl addressbook.capnp</code>, resulting in
a <code>addressbook.capnp.hrl</code>-file, these functions are defined (as <code>addressbook/N</code>):
<dl>
  <dt>Write value to object field.</dt>
  <dd><code>fun((set, Field::atom(), Value::term(), <a href="#type-object">object()</a>) -&gt; ok)</code></dd>

  <dt>Get a reference to the root object in message.</dt>
  <dd><code>fun((root, Type::atom() | integer(), Message::[binary()]) -&gt; {ok, Root::<a href="#type-object">object()</a>})</code></dd>

  <dt>Read object field value.</dt>
  <dd><code>fun((get, Field::atom(), <a href="#type-object">object()</a>) -&gt; term())</code></dd>

  <dt>Type cast object to another struct or list.</dt>
  <dd><code>fun((to_struct, Type::atom() | integer(), <a href="#type-object">object()</a>) -&gt; <a href="#type-object">object()</a>)</code><br>
      <code>fun((to_list, Type::atom() | integer(), <a href="#type-object">object()</a>) -&gt; list())</code></dd>

  <dt>Set root type for a new message.</dt>
  <dd><code>fun((root, Type::atom() | integer()) -&gt; {ok, Root::<a href="#type-object">object()</a>})</code></dd>

  <dt>Read unnamed union value of object.</dt>
  <dd><code>fun((get, <a href="#type-object">object()</a>) -&gt; Tag::atom() | {Tag::atom(), Value::term()})</code></dd>

  <dt>Type cast object to text/data.</dt>
  <dd><code>fun((to_text | to_data, <a href="#type-object">object()</a>) -&gt; binary())</code></dd>

  <dt>Get the compiled schema.</dt>
  <dd><code>fun((schema) -&gt; <a href="#type-schema">schema()</a>)</code></dd>
</dl>

<h5><a name="Writing_an_addressbook">Writing an addressbook</a></h5>

<p>To write a addressbook message, we first need a <code>AddressBook</code> root object:</p>

<p><code>{ok, AddressBook} = addressbook(root, 'AddressBook').</code></p>

<p>Now, we can fill in the details. Let's add two people, and call them
<code>Alice</code> and <code>Bob</code>:</p>

<p><code>[Alice, Bob] = addressbook(set, people, 2, AddressBook).</code></p>

<p>Now, <code>Alice</code> has one phone number, while <code>Bob</code> has two:</p>

<p><code>[addressbook(set, phones, N, P) || {P, N} &lt;- [{Alice, 1}, {Bob, 2}]].</code></p>

<p>Ok, we're all set to fill in the blanks of the people and phone objects we have allocated:</p>

<pre>
<code>[addressbook(set, Field, Value, Obj)
 || {Obj, FieldValue} &lt;-
          [{Alice,
                [{id, 123},
                 {name, &lt;&lt;"Alice"&gt;&gt;},
                 {email, &lt;&lt;"alice@example.com"&gt;&gt;},
                 {employment, {shool, &lt;&lt;"MIT"&gt;&gt;}},
                 {phones, {0, {number, &lt;&lt;"555-1212"&gt;&gt;}}},
                 {phones, {0, {type, mobile}}}]},
           {Bob,
                [{id, 456},
                 {name, &lt;&lt;"Bob"&gt;&gt;},
                 {email, &lt;&lt;"bob@example.com"&gt;&gt;},
                 {employment, unemployed},
                 {phones, {0, {number, &lt;&lt;"555-4567"&gt;&gt;}}},
                 {phones, {0, {type, home}}},
                 {phones, {1, {number, &lt;&lt;"555-7654"&gt;&gt;}}},
                 {phones, {1, {type, mobile}}}]}],
    {Field, Value} &lt;- FieldValues].</code>
</pre>

<p>There's quite a number of <code>addressbook(set, ...)</code>-calls there. Also
note that we could have saved a reference to the phone objects
directly and used those instead of embedding them in the calls to
Alice and Bob, when we allocated the phone objects, the same way we
saved the result when allocating people.</p>

<p>All that is left now is to get the message out. Here's how to get a
packed binary ready for dispatching:</p>

<p><code>Data = ecapnp_serialize:pack(ecapnp_message:write(AddressBook)).</code></p>

<p>If you intend to send it to <code>io</code>, make sure it uses <code>unicode</code> encoding:</p>

<p><code>io:setopts([{encoding, unicode}]).</code> will take care of it.</p>


<h5><a name="Reading_an_addressbook_message">Reading an addressbook message</a></h5>

<p>To be written...</p>


<h3><a name="Project_info">Project info</a></h3>
<dl>
  <dt>Project page</dt><dd><a href="http://ecapnp.astekk.se" target="_top"><tt>http://ecapnp.astekk.se</tt></a></dd>
  <dt>Source code</dt><dd><a href="http://github.com/kaos/ecapnp" target="_top"><tt>http://github.com/kaos/ecapnp</tt></a></dd>
  <dt>Cap'n Proto</dt>
  <dd>
    Home: <a href="http://capnproto.com" target="_top"><tt>http://capnproto.com</tt></a> <br>
    Code: <a href="http://github.com/kentonv/capnproto" target="_top"><tt>http://github.com/kentonv/capnproto</tt></a>
  </dd>
  <dt>License</dt><dd>
   <pre>Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.</pre>
  </dd>
</dl>

<hr>
<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Oct 15 2013, 14:21:02.</i></p>
</body>
</html>
