{"name":"ecapnp","tagline":"Cap'n Proto library for Erlang","body":"ecapnp\r\n======\r\n\r\nCap'n Proto library for Erlang.\r\n\r\nNOTICE: Not all schema features are yet implemented.\r\n\r\n\r\nPrerequisites\r\n-------------\r\n\r\nNaturally, the\r\n[Cap'n Proto](http://kentonv.github.io/capnproto/index.html) framework\r\nis needed in order to compile any `.capnp` schema files.\r\n\r\n\r\nUsage\r\n=====\r\n\r\nBuild and install `ecapnp` somewhere in you `ERL_LIBS` path.\r\n\r\nThen use `capnp` to compile schema files to be used in Erlang:\r\n\r\n```\r\n   capnp compile -oerl <schemafile.capnp>\r\n```\r\n\r\nSee `capnp compile --help` for compile options.\r\n\r\nInclude the compiled `schemafile.capnp.hrl` header file in the module\r\nwhere you need to read Cap'n Proto messages.\r\n\r\n\r\nBasic API\r\n=========\r\n\r\nThe compiled schema adds a few functions to help read messages.\r\n\r\n* `schemafile(root, 'RootStructTypeName', Message) :: {ok, RootObject}`\r\n\r\n   Get the message's root object. `Message` is a list of binary\r\n   segments, as returned by `ecapnp_message:read/1`.\r\n\r\n* `schemafile(root, 'RootStructTypeName') :: {ok, RootObject}`\r\n\r\n   Create a new message with the given root object.\r\n   \r\n* `schemafile(get, FieldName, Object) :: Value | Object | list(Object)`\r\n\r\n   Read `FieldName` of `Object`. For data fields, this results in a\r\n   standard Erlang value, where as for objects it is a opaque value to\r\n   be passed in another get field value request. List values are also\r\n   plain Erlang lists, where each list element's value follows the\r\n   above rules.\r\n\r\n* `schemafile(set, FieldName, Value, Object) :: ok | list(Object)`\r\n\r\n   Write `Value` to `FieldName` of `Object`. In case the field is a list\r\n   of objects, the `Value` should be number of elements to allocate for\r\n   the list, and the result is a list of objects.\r\n   The implementation of other list types are incomplete at this moment.\r\n   \r\n* `schemafile(schema) :: schema()`\r\n\r\n   This returns the entire message schema.\r\n\r\nThe library has a few exported functions as well:\r\n\r\n* `ecapnp:get_root(Type, Schema, Message) :: {ok, RootObject}`\r\n\r\n   This is the function wrapped by `schemafile(root, ...)`.\r\n\r\n* `ecapnp:set_root(Type, Schema) :: {ok, RootObject}`\r\n\r\n   This is the function wrapped by `schemafile(root, ...)`.\r\n\r\n* `ecapnp:get(Field, Object) :: Value | Object`\r\n\r\n   This is the function wrapped by `schemafile(get, ...)`.\r\n\r\n* `ecapnp:set(Field, Value, Object) :: ok | list(Object)`\r\n\r\n   This is the function wrapped by `schemafile(set, ...)`.\r\n\r\n* `ecapnp_message:read(Data) :: Message`\r\n\r\n   Parse a binary Cap'n Proto message. The `Data` should begin with\r\n   the message header (segment count and sizes) followed by the\r\n   segment data.\r\n\r\n* `ecapnp_message:write(Object) :: binary()`\r\n\r\n   Build a binary Cap'n Proto message with proper message header. Any\r\n   `Object` that belongs to the message may be used as argument to\r\n   this call.\r\n\r\n* `ecapnp_serialize:unpack(Data) :: binary()`\r\n\r\n   If a message is packed, it has to be unpacked prior to reading it\r\n   with `ecapnp_message:read/1`.\r\n   \r\n* `ecapnp_serialize:pack(Data) :: binary()`\r\n\r\n   Any message can be packed in order to reduce the message size.\r\n\r\n* `ecapnpc:compile_file(FileName)`\r\n  `ecapnpc:compile_data(Binary)`\r\n  `ecapnpc:compile_message(Message)`\r\n\r\n   The `ecapnpc` module takes care of taking a capnp `schema` message,\r\n   and compile it to a erlang header file.\r\n\r\n\r\nSample\r\n======\r\n\r\nIn the Cap'n Proto distribution there is a AddressBook example. The\r\nsame example is provided in a `escript` version in the `priv/samples`\r\ndirectory.\r\n\r\nThis version packs/unpacks the messages, so it works the same as the\r\nC++ counterpart, and can be used interchangeably.\r\n\r\n\r\nBUGS!!\r\n======\r\n\r\nOn *Windows* (should you be unfortunate enough to be on that platform)\r\nthere is a rather bad design decision in Erlang to convert all `\\r` to\r\n`\\n` that are read from `stdin`. Either patch `beam.smp.dll`, the\r\nsource, or avoid reading Cap'n Proto messages from `stdin`.\r\n\r\n(I have a patch for erl 5.9.3.1 if you need one)\r\n","google":"UA-8367989-4","note":"Don't delete this file! It's used internally to help with page regeneration."}